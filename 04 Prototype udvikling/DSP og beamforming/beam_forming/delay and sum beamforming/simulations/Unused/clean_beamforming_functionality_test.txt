clean_beamforming_functionality_test

ANGLE, BEAMFORMING OUTPUT AOA
-90, -90.0000
-85, -84.9550
-80, -80.0901
-75, -75.0450
-70, -70.0000
-65, -64.9550
-60, -60.0901
-55, -55.0450
-50, -50.0000
-45, -44.9550
-40, -40.0901
-35, -35.0450
-30, -30.0000
-25, -24.9550
-20, -20.0901
-15, -15.0450
-10, -10.0000
-5, -4.9550
0, 0.0901
5, 4.9550
10, 10.0000
15, 15.0450
20, 20.0901
25, 24.9550
30, 30.0000
35, 35.0450
40, 40.0901
45, 44.9550
50, 50.0000
55, 55.0450
60, 60.0901
65, 64.9550
70, 70.0000
75, 75.0450
80, 80.0901
85, 84.9550
90, -90.0000

##########################################################################
TEST CODE
##########################################################################
import numpy as np

def beamforming_das(rx, distance, no_ele):
    theta_sweep = np.linspace(-1*np.pi/2, np.pi/2, 1000)
    results = []
    for thetas in theta_sweep:
       w = np.exp(2j * np.pi * distance * np.arange(no_ele) * np.sin(thetas))
       y = w.conj().T @ rx
       results.append(np.abs(np.sum(y)))
    return np.rad2deg(theta_sweep[np.argmax(results)])

sample_rate = 61.44e6
N = 10000
t = np.arange(N)/sample_rate


### TX SIGNAL

angles = np.arange(-90, 95, 5)
print("ANGLE, BEAMFORMING OUTPUT AOA")
for angle in angles:
    theta_deg = 0 # Angle of arrival
    theta_rad = np.deg2rad(angle)
    f = 2e4
    tx = np.exp(2j * np.pi * f * t)
    d = 0.5
    elements = 2
    k = np.arange(elements)

    s = np.exp(2j * np.pi * d * k * np.sin(theta_rad))
    s = s.reshape(-1,1)
    tx = tx.reshape(1,-1)

    ### RX SIGNAL
    X = s @ tx
    n = np.random.randn(elements, N) + 1j*np.random.randn(elements, N)
    X_n = X + 0.0 * n

    ### TEST CODE
    ## FUNCTIONALITY TEST
    bf_signal = beamforming_das(X_n, d, elements)
    print(f"{angle}, {bf_signal:.4f}")