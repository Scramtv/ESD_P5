dirty_beamforming_functionality_test

ANGLE, BEAMFORMING OUTPUT AOA
-90, 87.6577
-85, -82.7928
-80, -79.1892
-75, -75.9459
-70, -68.3784
-65, -64.0541
-60, -60.0901
-55, -54.8649
-50, -50.0000
-45, -45.4955
-40, -39.9099
-35, -35.0450
-30, -30.1802
-25, -24.9550
-20, -20.2703
-15, -15.0450
-10, -10.0000
-5, -5.4955
0, 0.4505
5, 5.3153
10, 10.1802
15, 14.5045
20, 19.5495
25, 25.1351
30, 29.6396
35, 35.7658
40, 39.7297
45, 44.9550
50, 49.0991
55, 54.6847
60, 60.2703
65, 64.4144
70, 69.4595
75, 73.9640
80, 80.0901
85, 86.7568
90, 86.3964

##########################################################################
TEST CODE
##########################################################################
import numpy as np

def beamforming_das(rx, distance, no_ele):
    theta_sweep = np.linspace(-1*np.pi/2, np.pi/2, 1000)
    results = []
    for thetas in theta_sweep:
       w = np.exp(2j * np.pi * distance * np.arange(no_ele) * np.sin(thetas))
       y = w.conj().T @ rx
       results.append(np.abs(np.sum(y)))
    return np.rad2deg(theta_sweep[np.argmax(results)])

sample_rate = 61.44e6
N = 10000
t = np.arange(N)/sample_rate


### TX SIGNAL

angles = np.arange(-90, 95, 5)
print("ANGLE, BEAMFORMING OUTPUT AOA")
for angle in angles:
    theta_deg = 0 # Angle of arrival
    theta_rad = np.deg2rad(angle)
    f = 2e4
    tx = np.exp(2j * np.pi * f * t)
    d = 0.5
    elements = 2
    k = np.arange(elements)

    s = np.exp(2j * np.pi * d * k * np.sin(theta_rad))
    s = s.reshape(-1,1)
    tx = tx.reshape(1,-1)

    ### RX SIGNAL
    X = s @ tx
    n = np.random.randn(elements, N) + 1j*np.random.randn(elements, N)
    X_n = X + 0.1 * n

    ### TEST CODE
    ## FUNCTIONALITY TEST
    bf_signal = beamforming_das(X_n, d, elements)
    print(f"{angle}, {bf_signal:.4f}")